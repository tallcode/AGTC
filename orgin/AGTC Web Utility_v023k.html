<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AGTC Web Utility</title>
    <style>
        body { font-family: Tahoma; background-color: #1e1e1e; color: #cccccc; padding: 30px; }
        h1 { color: #dcdcdc; margin-bottom: 10px; }
		h2 { color: #2AA63E; font-size: 20px;}
		h3 { color: #dcdcdc; font-size: 15px;  }
        
        .input-group { margin-bottom: 10px; font-size: 20px; }
        label { display: inline-block; width: 250px; }
        input[type="number"] { width: 100px; padding: 5px; background: #3c3c3c; color: #fff; border: 1px solid #555; font-size: 20px; }
        input[type="file"] { color: #fff; font-size: 20px; }
        button { padding: 10px 20px; background-color: #007acc; color: white; border: none; cursor: pointer; font-size: 20px; margin-top: 10px; }
        button:hover { background-color: #0098ff; }
        
        /* --- 按钮下方输出内容整体外框样式 --- */
        #results { 
            margin-top: 20px; 
            white-space: pre-wrap; 
            font-family: 'Consolas', Courier, monospace; 
            border: 1px solid #555555; /* 边框颜色 */
            padding: 15px;             /* 边框内边距 */
            background-color: #000000; /* 稍亮的深色背景，突出显示区域 */
            border-radius: 4px;        /* 稍微圆角化 */
            max-width: 700px;          /* 匹配表格的最大宽度加内边距 */
        }
        
        /* 头部输出文字间距控制 */
        .res-header { color: #ffffff; margin-bottom: 10px; line-height: 0.4; }
        .res-header div { margin-bottom: 3px; }
        
        /* 表格样式优化 */
        .res-table { border-collapse: collapse; width: 100%; max-width: 700px; margin-top: 10px; }
        .res-table th, .res-table td { padding: 2px 5px; text-align: center; line-height: 0.8; }
        .res-table th { color: #e5e54c; border-bottom: 2px solid #555; }
        .res-table td { color: #e5e54c; }
        
        .res-warning { color: #d94848; }
        .res-info { color: #5555ff; }
        .res-gta-neg { color: #ff00ff; }
        
        .val-avg { color: #ffffff; }
        .val-sky { color: #5555ff; }
        .val-earth { color: #5555ff; }
        .val-loss { color: #ffffff; }

        .row-highlight td { color: #d94848 !important; font-weight: bold; }
    </style>
</head>
<body>

    <h1>AGTC Web Utility</h1>
	<h2>Based on "AGTC_anyGTa_2lite"</h2>
	<h2>G/Ta computation from Far Field Table by F5FOD with DG7YBN</h2>

    <div class="input-group">
        <label for="skyTemp">Sky Temperature (K):</label>
        <input type="number" id="skyTemp" value="20" step="1">
    </div>
	
    <div class="input-group">
        <label for="earthTemp">Earth Temperature (K):</label>
        <input type="number" id="earthTemp" value="350" step="1">
    </div>
	
	<div class="input-group">
        <label for="translineLoss">Trans. Line Loss (dB):</label>
        <input type="number" id="translineLoss" value="0.20" step="0.01">
    </div>
	
	<div class="input-group">
        <label for="ReceiverNF">Receiver NF (dB):</label>
        <input type="number" id="ReceiverNF" value="0.75" step="0.01">
    </div>

    <div class="input-group">
        <label for="fileInput">Input FFtab file (.txt):</label>
        <input type="file" id="fileInput" accept=".txt">
    </div>

    <div>
        <button onclick="processFile()">Calculate</button>
    </div>

    <div id="results"></div>

    <script>
        const PI = Math.PI;
        let tot_dB = []; // 181 x 361

var T_pattern;
var T_total;
var Ta;  // Tpattern at 30 deg. of elevation
var La;  // Antenna Loss Factor
var translineLoss;  // User input in dB
var L_TL;  // Loss Factor of Transmission Line
var T_TL;  // Noise Temperature of Transmission Line
var ReceiverNF;   // Noise Figure of Receiver
var T_rec; // Noise Temperature of Receiver
var Tsys;  // Overall System Noise Temperature

var maxGainVal;
var D_num; // Antenna Directivity as Factor
var D_dB;  // Antenna Directivity in dB
var GTsys;

        function initArray() {
            tot_dB = new Array(181);
            for(let i=0; i<181; i++) {
                tot_dB[i] = new Float64Array(361).fill(-100.0);
            }
        }

        function processFile() {
            const fileInput = document.getElementById('fileInput');
            const skyTemp = parseFloat(document.getElementById('skyTemp').value);
            const earthTemp = parseFloat(document.getElementById('earthTemp').value);
			translineLoss = parseFloat(document.getElementById('translineLoss').value);
			ReceiverNF = parseFloat(document.getElementById('ReceiverNF').value);

            if (!fileInput.files.length) {
                alert("Please select a Far Field Table (FFtab) file first.");
                return;
            }

            const file = fileInput.files[0];
            const reader = new FileReader();

            reader.onload = function(e) {
                const text = e.target.result;
                try {
                    parseData(text);
                    calculate(skyTemp, earthTemp, translineLoss, ReceiverNF, file.name);
                } catch (err) {
                    alert("Error processing file: " + err.message);
                    console.error(err);
                }
            };

            reader.readAsText(file);
        }

        function parseData(text) {
            initArray();
            const lines = text.split(/\r?\n/);
            
            // State
            let currentVariable = -1; // The angle value from the header
            let sliceMode = null; // 'phi_fixed' (Deg is Theta) or 'theta_fixed' (Deg is Phi)
            
            // Helper for comma decimals
            const parseVal = (s) => parseFloat(s.replace(',', '.'));

            // Regexes - Updated to allow commas
            // Case 1: "Theta Pattern   Phi angle = 0 deg"  => Phi is fixed, data varies by Theta
            const regexPhiHeader = /Phi angle\s*=\s*([-\d\.,]+)/;
            
            // Case 2: "Phi Pattern   Theta angle = 0 deg" => Theta is fixed, data varies by Phi
            const regexThetaHeader = /Theta angle\s*=\s*([-\d\.,]+)/;

            // Case 3: "Azimuth Pattern   Elevation angle = 23 deg" => Elevation is fixed, data varies by Azimuth (Phi)
            // Note: EZNEC Elevation = 90 - Theta (usually).
            const regexElevationHeader = /Elevation angle\s*=\s*([-\d\.,]+)/;

            // Matches: Deg, V dB, H dB, Tot dB. Handles negative numbers.
            // Example: "  0    -7.86    -42.28     -7.85"
            // Example: "  0    -7,86    -42,28     -7,85"
            const regexData = /^\s*(\d+)\s+([-\d\.,]+)\s+([-\d\.,]+)\s+([-\d\.,]+)/;

            for (let line of lines) {
                // Check headers
                const phiMatch = line.match(regexPhiHeader);
                if (phiMatch) {
                    currentVariable = parseVal(phiMatch[1]);
                    sliceMode = 'phi_fixed'; // Based on FFtab.txt
                    continue;
                }

                const thetaMatch = line.match(regexThetaHeader);
                if (thetaMatch) {
                    currentVariable = parseVal(thetaMatch[1]);
                    sliceMode = 'theta_fixed'; // Based on FFtab1.txt
                    continue;
                }

                const elevMatch = line.match(regexElevationHeader);
                if (elevMatch) {
                    // Convert Elevation to Theta: Theta = 90 - Elevation
                    // Treat as theta_fixed because data varies by Azimuth (Phi)
                    currentVariable = 90.0 - parseVal(elevMatch[1]);
                    sliceMode = 'theta_fixed'; 
                    continue;
                }

                // Check for Data line
                const dataMatch = line.match(regexData);
                if (dataMatch && sliceMode) {
                    let deg = parseInt(dataMatch[1]);
                    let val = parseVal(dataMatch[4]); // Tot dB is 4th capture group

                    let theta, phi;

                    if (sliceMode === 'phi_fixed') {
                        // In this mode, header specified Phi. 
                        // The 'Deg' column is Theta (Pattern is Theta Pattern).
                        // FFtab.txt logic: Deg can go 0..360.
                        // 0..180 => Theta=Deg, Phi=currentVariable
                        // 181..359 => Theta=360-Deg, Phi=(currentVariable+180)%360
                        
                        let fixedPhi = currentVariable;
                        
                        if (deg <= 180) {
                            theta = deg;
                            phi = fixedPhi;
                        } else {
                            theta = 360 - deg;
                            phi = (fixedPhi + 180) % 360;
                        }

                    } else if (sliceMode === 'theta_fixed') {
                        // In this mode, header specified Theta.
                        // The 'Deg' column is Phi (Pattern is Phi Pattern).
                        // FFtab1.txt logic: Deg is Phi (0..360).
                        
                        theta = currentVariable;
                        phi = deg;
                    }

                    // Store Data
                    // Safety mapping and bounds check
                    // Ensure Phi is 0..360 (wrap 360 to 0 if needed or keep 360 as alias)
                    // Our array logic handles phi 0..360 index directly for trapezoidal consistency
                    
                    if (theta >= 0 && theta <= 180 && phi >= 0 && phi <= 360) {
                        // Round to nearest integer indices just in case inputs are float
                        let t_idx = Math.round(theta);
                        let p_idx = Math.round(phi);
                        
                        if (t_idx < 181 && p_idx < 361) {
                             tot_dB[t_idx][p_idx] = val;
                             
                             // Handle 360 wrap consistency
                             if (p_idx === 0) tot_dB[t_idx][360] = val;
                             if (p_idx === 360) tot_dB[t_idx][0] = val;
                        }
                    }
                }
            }
        }

        function calculate(T_sky, T_earth, fileName) {
            // Arrays for integration
            // element[181 * phi + theta] 
            // We'll Use a flattened or 2D structure. 2D is easier in JS: element[phi][theta]
            // Note BASIC used flattened array index = 181 * phi + theta + 1
            // We will use 0-based: element[phi][theta], theta 0..180 (181), phi 0..360 (361)
            
            let element = new Array(361);
            maxGainVal = -1000;
            let maxPhi = 0;
            let maxTheta = 0;
            const dThetaRad = (PI / 180);
            const dPhiRad = (PI / 180); // Step is 1 deg
            const solidAngleFactor = dThetaRad * dPhiRad; // not strictly used if we follow BASIC's element formula which separates terms

            // Precompute elements
            for (let p = 0; p <= 360; p++) {
                element[p] = new Float64Array(181);
                for (let t = 0; t <= 180; t++) {
                    let db = tot_dB[t][p];
                    if (db > maxGainVal) {
                        maxGainVal = db;
                        maxPhi = p;
                        maxTheta = t;
                    }
                    // BASIC Formula: 10^(Tot_dB/10) * SIN(theta) * (PI/180)^2
                    let linear = Math.pow(10, db / 10.0);
                    let sinTheta = Math.sin(t * PI / 180.0);
                    element[p][t] = linear * sinTheta * Math.pow(PI / 180.0, 2);
                }
            }
            
            // Subroutine: Trapezoidal Sums
            // Inputs: begin_phi, end_phi, begin_theta, end_theta (Function of Phi? No in BASIC it's constant for the block)
            // Wait, BASIC:
            // FOR phi = begin_phi TO end_phi
            //    FOR theta = begin_theta TO end_theta ...
            // Wait, for Alpha rotation, limits depend on alpha?
            // "Sky1: az=0..90, el=90..-alpha (theta 0 to 90+alpha)"
            // Yes, standard limits.

            function trapezoidal_sums(b_phi, e_phi, b_theta, e_theta) {
                // b_theta/e_theta are numbers here (fixed for the region)
                // In BASIC logic:
                // Sum(phi) = Trapezoidal sum over theta
                // Sum_Sum = Trapezoidal sum over phi of Sum(phi)
                
                let sum_phi = new Float64Array(361);
                
                for (let p = b_phi; p <= e_phi; p++) {
                    let s = 0;
                    // Inner loop: theta from b_theta+1 to e_theta-1
                    for (let t = b_theta + 1; t <= e_theta - 1; t++) {
                         s += element[p][t];
                    }
                    // Add endpoints / 2
                    s += element[p][b_theta] / 2.0;
                    s += element[p][e_theta] / 2.0;
                    sum_phi[p] = s;
                }

                let sum_sum = 0;
                // Outer loop: phi from b_phi+1 to e_phi-1
                for (let p = b_phi + 1; p <= e_phi - 1; p++) {
                    sum_sum += sum_phi[p];
                }
                // Add endpoints / 2
                sum_sum += sum_phi[b_phi] / 2.0;
                sum_sum += sum_phi[e_phi] / 2.0;
                
                return sum_sum;
            }

            // Part 3: Calculate Avg Gain at Alpha 0
            // Sum Sky (0-90 theta) + Sum Earth (90-180 theta) for full sphere
            // BASIC does this by calling `areas` with alpha=0.
            
            function calculate_regions(alpha) {
                // Sky1: 0-90 phi, 0 to 90+alpha theta
                let sky1 = trapezoidal_sums(0, 90, 0, 90 + alpha);
                // Sky2: 270-360 phi, 0 to 90+alpha theta
                let sky2 = trapezoidal_sums(270, 360, 0, 90 + alpha);
                // Sky3: 90-270 phi, 0 to 90-alpha theta
                let sky3 = trapezoidal_sums(90, 270, 0, 90 - alpha);
                
                let sum_Sky = sky1 + sky2 + sky3;

                // Earth1: 0-90 phi, 90+alpha to 180 theta
                let earth1 = trapezoidal_sums(0, 90, 90 + alpha, 180);
                // Earth2: 270-360 phi, 90+alpha to 180 theta
                let earth2 = trapezoidal_sums(270, 360, 90 + alpha, 180);
                // Earth3: 90-270 phi, 90-alpha to 180 theta
                let earth3 = trapezoidal_sums(90, 270, 90 - alpha, 180);

                let sum_Earth = earth1 + earth2 + earth3;
                
                return { sum_Sky, sum_Earth };
            }

            // Calculate Avg Gain (Alpha = 0)
            const res0 = calculate_regions(0);
            const sum_Total_0 = res0.sum_Sky + res0.sum_Earth;
            const avg_gain_num = sum_Total_0 / (4 * PI);
			La = 1/avg_gain_num;
            const avg_gain_dB = 10 * Math.log10(avg_gain_num);
            
            const loss_dB = -avg_gain_dB;
            const loss_temperature = 290 * ((1.0 / avg_gain_num) - 1.0);
			
	
            // Generate HTML output			
            let html = `<div class="res-header">
                <div>Average Gain (AG) = <span class="val-avg"><b>${avg_gain_num.toFixed(4)} (/)</b>
				</span> = <span class="val-avg"><b>${avg_gain_dB.toFixed(2)}</b> dBi</span>, Loss Factor L_a = <span class="val-loss"><b>${La.toFixed(4)}</b> (/)</span>
				</div>
                <div>Max Gain = <span class="val-avg"><b>${maxGainVal.toFixed(2)}</b> dBi</span> at azimuth = <b>${maxPhi}</b> degree(s) and elevation = <b>${90 - maxTheta}</b> degree(s)</div>
				
				<div style="display:flex; gap:20px;">
                     <span class="val-sky">T_sky = <b>${T_sky.toFixed(2)}</b> K</span>
                     <span class="val-earth">T_earth = <b>${T_earth.toFixed(2)}</b> K</span>
                </div>
            </div>`;

            html += `<table class="res-table">
                <thead>
                    <tr>
                        <th>Alpha (deg.)</th>
                        <th>T_pattern (K)</th>
                        <th>T_loss (K)</th>
                        <th>T_total (K)</th>
                        <th>G/Ta (dB)</th>
                    </tr>
                </thead>
                <tbody>`;
				
		
            // Loop Alpha
            for (let alpha = 0; alpha <= 90; alpha += 5) {
                const res = calculate_regions(alpha);
                const sumS = res.sum_Sky;
                const sumE = res.sum_Earth;
                
                T_pattern = (T_sky * sumS + T_earth * sumE) / (sumS + sumE);
                T_total = (T_pattern - 290) * avg_gain_num + 290;				
				
                let G_Ta_dB;
                let G_Ta_Str;
                let rowClass = "";

                if (T_total <= 0) {
                    G_Ta_Str = "-99.999 *";
                    // Error case
                } else {
                    G_Ta_dB = maxGainVal - 10 * Math.log10(T_total);
                    G_Ta_Str = G_Ta_dB.toFixed(3);					
                }

                if (alpha === 30) rowClass = "row-highlight";
                
                const T_loss = loss_temperature * avg_gain_num;
				
                const formatNum = (n) => (n >= 0 ? "+ " : "- ") + Math.abs(n).toFixed(3);
				
				// Pick T_pattern at 30 deg. of elevation for G/Tsys
				if (alpha == 30){
				Ta = T_pattern;
				
				// Calculation of G/T system
				translineLoss = translineLoss/10
				L_TL = Math.pow(10, translineLoss);
				T_TL = (L_TL - 1) * 290;
				ReceiverNF = ReceiverNF/10
				T_rec = 290 * (Math.pow(10, ReceiverNF)-1);
				
				Tsys = Ta + (La - 1) * 290 + La * (L_TL - 1) * 290 + La * L_TL * T_rec;
				
				maxGainVal = maxGainVal/10
				D_num =  La * (Math.pow(10, maxGainVal));
				D_dB = 10 * Math.log10(D_num);
				GTsys = D_dB - 10 * Math.log10(Tsys);
				
				};

                html += `<tr class="${rowClass}">
                    <td>${alpha}</td>
                    <td>${T_pattern.toFixed(3)}</td>
                    <td>${formatNum(T_loss)}</td>
                    <td>${formatNum(T_total)}</td>
                    <td>${formatNum(G_Ta_dB)}</td>
                </tr>`;
            }
			html += `<table class="res-table">
                <thead>
					<tr>
						<th> </th>
                    </tr>
                    <tr>
                        <th>G/Tsys = ${GTsys.toFixed(2)} dB/K (alpha = 30 deg. T_rec = ${T_rec.toFixed(2)} K, T_TL = ${T_TL.toFixed(2)} K)</th>
                    </tr>
                </thead>
                <tbody>`;

            html += `</tbody></table>`;
				
            // Warnings
            if (avg_gain_num >= 1.001) {
                 html += `<div class="res-gta-neg" style="margin-top:10px">Computed AG >= 1.001, G/Ta corrections may be needed</div>`;
            }
			
            document.getElementById('results').innerHTML = html;
        }

    </script>
</body>
</html>
